# MIT License
#
# Copyright (c) 2023 Yu Du
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Binding Curve Viewer: Visualizing the Equilibrium and Kinetics of Protein-Ligand Binding and Competitive Binding"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

__author__ = "Yu Du <orcid.org/0000-0002-4114-396X>"
__version__ = "1.0.0"


def second_order_asso_points(p0=100, l0=150, koff=1e-2, kon=1e5):
    r"""The function ``second_order_asso_points`` generates a tuple of time v.s. :math:`[PL]` points
    in the association process of the second order binding reaction, and a list of the time to 95%
    equilibrium (``t95``). The initial concentration in this function means the working concentration
    in the binding reaction initiated by mixing an arbitrary volume of protein with an arbitrary
    volume of ligand.

    Parameters
    ----------
    p0 : float
        The initial concentration of free proteins in the unit of nM (default value is 100).
    l0 : float
        The initial concentration of free ligands in the unit of nM (default value is 150).
    koff : float
        The value of dissociation rate constant (:math:`k_{off}`) in the unit of s\ :sup:`-1`
        (default value is 1e-2).
    kon : float
        The value of association rate constant (:math:`k_{on}`) in the unit of M\ :sup:`-1` s\ :sup:`-1`
        (default value is 1e5).

    Returns
    -------
    Tuple
        A tuple of ``second_order_time`` (a list of time), ``second_order_pl`` (a list of
        corresponding :math:`[PL]`), and the time to 95% equilibrium (``t95``). These values can
        be used in curve fitting and data analysis.
    """
    plot_points = 100  # The number of steps in the binding process (default value is 100).
    kon = kon * 1e-9  # change kon's unit from M-1 s-1 to nM-1 s-1
    a = 1
    b = 0 - (p0 + l0 + koff / kon)
    c = p0 * l0
    pl_1 = (0 - b - np.sqrt(b * b - 4 * a * c)) / (2 * a)  # pl_1 is [PL]eq, pl_1 < pl_2
    pl_2 = (0 - b + np.sqrt(b * b - 4 * a * c)) / (2 * a)
    A = 1 / (pl_1 - pl_2)
    num_array = np.arange(0, plot_points, 1) / plot_points
    second_order_pl = pl_1 * num_array
    pl_95perc = 0.95 * pl_1  # [PL] at 95% equilibrium
    t95 = A / kon * np.log((pl_2 * (pl_1 - pl_95perc)) / (pl_1 * (pl_2 - pl_95perc)))  # time for 95% equilibrium
    second_order_time = A / kon * np.log((pl_2 * (pl_1 - second_order_pl)) / (pl_1 * (pl_2 - second_order_pl)))
    return second_order_time, second_order_pl, t95

if __name__ == '__main__':
    conc_serial = range(1, 201)
    p0 = 100  # nM
    l0_step = 25  # nM
    koff = 1e-2
    kon = 1e5

    def kon_koff_calc(l1, l2, kobs_fit1, kobs_fit2):
        kon_fit = (kobs_fit2 - kobs_fit1) / (l2 - l1)
        koff_fit = kobs_fit2 - kon_fit * l2
        return (kon_fit, koff_fit)

    case_num = 20
    dindex = 2  # e.g., l1 = 100 nM, l2 = l1 + l0_step (25 nM) * dindex (2)
    plot_data = {'title': ['(A, A + ' + str(l0_step * dindex * num) + ' nM)'
                           for num in range(1, case_num + 1)],
                 'l0_xdata': [],
                 'koff_ratio_y': [],
                 'kon_ratio_y': [],
                 }
    # curve fitting
    # use pseudo-first-order equation to fit the data generated by second-order process
    kobs_fit_list = []
    kobs_ratio_list = []  # kobs_fit / kobs
    l_p_ratio_list = []  # [L]0 / [P]0
    l0_list = []
    pl_endpoint_idx = 99
    sample_idx = np.round(np.linspace(0, pl_endpoint_idx, 6)).astype(int)
    for i in conc_serial:
        l0 = l0_step * i
        l0_list.append(l0)
        l_p_ratio_list.append(l0 / p0)
        kobs = kon * l0 * 1e-9 + koff
        second_order_time, second_order_pl, t95 = second_order_asso_points(p0, l0, koff, kon)
        samples_time = [second_order_time[idx] for idx in sample_idx]
        samples_pl = [second_order_pl[idx] for idx in sample_idx]

        def each_curve(t, kobs):
            # second_order_pl[-1] approximates the pl_eq
            # pl = pl_eq * (1 - np.exp(0 - kobs * t)), see the paper's SI, for the derivation of the equation
            return samples_pl[-1] * (1 - np.exp(-kobs * t))

        # the bounds means kobs > 0
        # fitting method is ‘trf’ if bounds are provided
        popt_bound, pcov_bound = curve_fit(each_curve, samples_time, samples_pl, bounds=(0, np.inf))
        kobs_fit = popt_bound[0]
        kobs_fit_list.append(kobs_fit)
        kobs_ratio_list.append(kobs_fit / kobs)

    for num in range(1, case_num + 1):
        delta = dindex * num
        kon_fit_list = []
        koff_fit_list = []
        kon_ratio_list = []
        koff_ratio_list = []
        # calculate the slope (kon) and intercept (koff) of the line defined by two ([L], kobs_fit) data points
        # the [L] of these two data points are separated by delta
        for i in conc_serial[:-(delta + 1)]:
            l1 = l0_list[i]
            l2 = l0_list[i + delta]
            kobs_fit1 = kobs_fit_list[i]
            kobs_fit2 = kobs_fit_list[i + delta]
            kon_fit, koff_fit = kon_koff_calc(l1, l2, kobs_fit1, kobs_fit2)
            kon_fit_list.append(kon_fit)
            kon_ratio_list.append(kon_fit * 1e9 / kon)
            koff_fit_list.append(koff_fit)
            koff_ratio_list.append(koff_fit / koff)
        l0_xdata = l0_list[:-(delta + 1)]
        plot_data['l0_xdata'].append(l0_xdata[:])
        plot_data['koff_ratio_y'].append(koff_ratio_list[:])
        plot_data['kon_ratio_y'].append(kon_ratio_list[:])

    fig1, axs1 = plt.subplots(5, 4, figsize=(11, 12))
    for ax, idx in zip(axs1.flat, range(case_num)):
        condition = np.logical_and(0.95 < np.array(plot_data['koff_ratio_y'][idx]),
                                   np.array(plot_data['koff_ratio_y'][idx]) < 1.05)
        col = np.where(condition, 'r', 'k')
        ax.set_title(plot_data['title'][idx])
        ax.scatter(plot_data['l0_xdata'][idx], plot_data['koff_ratio_y'][idx], c=col, s=2)
        ax.set_xlabel(r'$[L]_0$ (nM)')
        ax.set_ylabel(r'$k_{off}$_fit/$k_{off}$')
    fig1.tight_layout()
    fig1.savefig('Fig.S4-koff.png')
    fig2, axs2 = plt.subplots(5, 4, figsize=(11, 12))
    for ax, idx in zip(axs2.flat, range(case_num)):
        condition = np.logical_and(0.95 < np.array(plot_data['kon_ratio_y'][idx]),
                                   np.array(plot_data['kon_ratio_y'][idx]) < 1.05)
        col = np.where(condition, 'r', 'k')
        ax.set_title(plot_data['title'][idx])
        ax.scatter(plot_data['l0_xdata'][idx], plot_data['kon_ratio_y'][idx], c=col, s=2)
        ax.set_xlabel(r'$[L]_0$ (nM)')
        ax.set_ylabel(r'$k_{on}$_fit/$k_{on}$')
    fig2.tight_layout()
    fig2.savefig('Fig.S5-kon.png')